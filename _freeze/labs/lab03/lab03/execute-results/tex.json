{
  "hash": "ec58e6d6e1406698ece436f37a9d3f7c",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"BEE 4750 Lab 3: Linear Programming with JuMP\"\ndate: last-modified\nformat:\n    html:        \n        warning: true\n        error: true\n    ipynb:\n        warning: true\n        error: true\n        code-annotation: below\n    pdf:\n        include-in-header: \n           text: |\n            \\usepackage{fvextra}\n            \\DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\\\\{\\}}\n            \\DefineVerbatimEnvironment{OutputCode}{Verbatim}{breaklines,commandchars=\\\\\\{\\}}\nexecute: \n    echo: true\nengine: julia\njulia:\n    exeflags: [\"+1.10.4\"]\nformat-links: [pdf, ipynb]\n---\n\n::: {.content-visible when-format=\"ipynb\"}\n**Name**:\n\n**ID**:\n:::\n\n::: {.callout-important icon=\"false\"}\n### Due Date\n\nWednesday, 10/16/24, 9:00pm\n:::\n\n::: {.content-visible when-format=\"html\"}\n::: callout-caution\nIf you are enrolled in the course, make sure that you use the GitHub Classroom link provided in Ed Discussion, or you may not be able to get help if you run into problems.\n\nOtherwise, you can [find the Github repository here]({{< var github_org.repo >}}/lab03).\n:::\n:::\n\n## Setup\n\nThe following code should go at the top of most Julia scripts; it will load the local package environment and install any needed packages. You will see this often and shouldn't need to touch it.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nimport Pkg\nPkg.activate(\".\")\nPkg.instantiate()\n```\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing JuMP # optimization modeling syntax\nusing HiGHS # optimization solver\n```\n:::\n\n\n\n\n## Overview\n\nIn this lab, you will write and solve a resource allocation example using `JuMP.jl`. `JuMP.jl` provides an intuitive syntax for writing, solving, and querying optimization problems.\n\n`JuMP` requires the loading of a solver. [Each supported solver works for certain classes of problems, and some are open source while others require a commercial license]. We will use the `HiGHS` solver, which is open source and works for linear, mixed integer linear, and quadratic programs.\n\nIn this lab we will walk through the steps involved in coding a linear program in HiGHS, solving it, and querying the solution.\n\n## Exercise (3 points)\n\nYour task is to decide how much lumber to produce to maximize profit from wood sales. You can purchase wood from a managed forest, which consists of spruce (320,000 bf) and fir (720,000 bf). Spruce costs $\\$0.12$ per bf to purchase and fir costs $\\$0.08$ per bf.\n\nAt the lumber mill, wood can be turned into plywood of various grades (see @tbl-inputs for how much wood of each type is required for and the revenue from each grade). Any excess wood is sent to be recycled into particle board, which yields no revenue for the mill. \n\n\n| Plywood Grade | Inputs (bf/bf plywood) | Revenue (\\$/1000 bf) |\n|:-------------:|:----------------------:|:--------------------:|\n|       1       |   0.5 (S) + 1.5 (F)    |         400          |\n|       2       |   1.0 (S) + 2.0 (F)    |         520          |\n|       3       |   1.5 (S) + 2.0 (F)    |         700          |\n\n: Wood inputs and revenue by plywood grade. S refers to spruce inputs, F fir inputs. {#tbl-inputs}\n\n\n\nFirst, we need to identify our decision variables. While there are several options, we will use $G_i$, the amount of each grade the mill produces (in 1000 bf). \n\nUsing these decision variables, formulate a linear program to maximize the profit of the mill subject to the supply constraints on spruce and fir.\n\n::: {.callout-tip}\n## JuMP Syntax\n\nThe core pieces of setting up a `JuMP` model involve specifying the model and adding variables, the objective, and constraints. At the most simple level, this syntax looks like this:\n\n```julia\nm = Model(HiGHS.Optimizer)\n@variable(m, lb <= x <= ub) # if you do not have upper or lower bounds, you can drop those accordingly\n@variable(m, lb <= y <= ub)\n@objective(m, Max, 100x + 250y) # replace Max with Min depending on the problem\n@constraint(m, label, 6x + 12y <= 80) # replace \"label\" with some meaningful string you would like to use later to query shadow prices, or drop it\n```\n\nYou can add more constraints or more variables as needed.\n\n:::\n\n\n::: {.callout-tip}\n## Using Array Syntax\n\nYou can set up multiple variables or constraints at once using array syntax. For example, the following are equivalent:\n\n```julia\n@variable(m, G1 >= 0)\n@variable(m, G2 >= 0)\n@variable(m, G3 >= 0)\n```\n\nand\n\n```julia\n@variable(m, G[1:3] >= 0)\n```\n\nYou can also set up multiple constraints using arrays of coefficients and/or bounds. For example:\n\n```julia\nI = 1:3\nd = [0; 3; 5]\n@constraint(m, demand[i in I], G[i] >= d[i])\n```\n:::\n\n`JuMP` is finicky about changing objects and constraints, so I recommend setting up all of the model syntax in one notebook cell, which is what we will do here.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nforest_model = Model(HiGHS.Optimizer) # initialize model object\n@variable(forest_model, G[1:3] >= 0) # non-negativity constraints\n# uncomment the following lines and add the objective and constraints as needed for the model\n# @objective(forest_model, )\n# @constraint(forest_model, )\nprint(forest_model) # this outputs a nicely formatted summary of the model so you can check your specification\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFeasibility\nSubject to\n G[1] ≥ 0\n G[2] ≥ 0\n G[3] ≥ 0\n```\n:::\n:::\n\n\n\nNext, to optimize, use the `optimize!()` function:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\noptimize!(forest_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning HiGHS 1.7.2 (git hash: 5ce7a2753): Copyright (c) 2024 HiGHS under MIT licence terms\nCoefficient ranges:\n  Cost   [0e+00, 0e+00]\n  Bound  [0e+00, 0e+00]\nSolving LP without presolve, or with basis, or unconstrained\nSolving an unconstrained LP with 3 columns\nModel   status      : Optimal\nObjective value     :  0.0000000000e+00\nHiGHS run time      :          0.00\n```\n:::\n:::\n\n\n\nYou should get confirmation that a solution was found; if one was not, there's a chance something was wrong with your model formulation.\n\nTo find the values of the decision variables, use `value()` (which can be broadcasted over variable arrays):\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n@show value.(G);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nvalue.(G) = [0.0, 0.0, 0.0]\n```\n:::\n:::\n\n\n\nSimilarly, `objective_value()` finds the optimal value of the objective:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n@show objective_value(forest_model);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nobjective_value(forest_model) = 0.0\n```\n:::\n:::\n\n\n\nFinally, we can find the dual values of the constraints with `shadow_price()`. Do this for the constraints in your model using the block below.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n# @show shadow_price(name_of_constraint);\n```\n:::\n\n\n\n`JuMP` also lets you evaluate other expressions that you might be interested in based on the solutions. For example, you can use the following block to calculate the total amount of plywood the mill would produce under the optimal solution:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n@expression(forest_model, total_plywood, sum(G))\n@show value.(total_plywood);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nvalue.(total_plywood) = 0.0\n```\n:::\n:::\n\n\n\n\n## References\n\nPut any consulted sources here, including classmates you worked with/who helped you.\n\n",
    "supporting": [
      "lab03_files/figure-pdf"
    ],
    "filters": []
  }
}